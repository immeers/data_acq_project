---
title: "A Predictive Analysis of Time Spent in Airport Arrivals in US"
author: "Imogen Meers, Sarah Deussing"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction
#### Topic
We want to understand airport arrival wait patterns by predicting future flight arrival times, the likelihood of delays and the time spent waiting in customs/passport control. We want to get all flight arrivals and custom wait times from Chicago O'Hare Airport from the last month. To do so, we will use:

1. A Form API of wait times for customs from international flights arriving into Chicago O'Hare, one of the major US airports.
   - https://awt.cbp.gov/
   

2. A REST API of historical flight arrivals data
    - https://rapidapi.com/oag-oag-default/api/flight-info-api
    Endpoint: GET /status - Get flight status by specifying arrival date range and arrivals airport


Our motivation for pursuing this problem is our experiences with international travel. We understand the stress of making connections and wasting time walking around new airports during travel. We chose Chicago O'Hare as it is our local internetional airport and one of the major airports within the US.

#### Significance
This research problem is significant as oftentimes, flights take longer than expected or airports have unexpected delays. We want to be able to minimize wasted time in the airport and understand the likelihood of making a connecting flight based on historical flight data from a number of different airports. 

When flying internationally into the United States, this information can be very useful to help plan one's travel. Based on their predicted total flight time, travelers can select connecting flights that minimize wasted time waiting around in the airport and allow for adequate times between flights. This prediction information will also help travelers decide what time to book taxis or hire cars, or decide what times to avoid because of business.

## Data Acquisition Process
Describe the methodology used to collect the data. This should include the tools used, the sampling method, and the sample size, the target population. Present any challenges or issues you found. Be thorough. 

#### The Form API data from: https://awt.cbp.gov/.
For this API, we are submitting 3 form elements: airportID, start date, and end date. Within each request, we added a short wait time to ensure we are not overloading the API with requests.

#### The REST API data from: https://rapidapi.com/oag-oag-default/api/flight-info-api
For this API, we had to create a free account with a limited number of requests.
Each API request provided 100 rows per page, and we extracted the desired information from nested tables in each row of the json file. Because we only have the free version of the API, we have a limited number of requests from the API. Our solution is to clean the JSON into a data frame with each request then append that data frame to a CSV.

## Flight Arrivals Data 
We obtained free API keys for the OAG info API and identified the GET status endpoint as the most suitable for our project. This endpoint provides data on:

  - Core Schedule information e.g. carrier, flight number, departure/arrival times, flight date, departure/destination airports

  - Estimate and actual times for gates

  - Estimate and actual times for runway

  - Flight delays, cancellations, diversions and recovery

  - Aircraft type and tail number

  - Departure/arrival gates and terminals

  - Check-in desk and baggage carousel

  - Codeshare

These will all be useful features to predict the future flight arrival information.


### Challenges

Originally, we wanted to get at least a year's worth of data but when we calculated the number of flights per day (up to 1000) and the page limit of 100, we realized this world take a huge amount of requests far beyond the usage limit for this API. We are only using a Basic Plan, which is 50 total requests with a maximum of 10 per min. 

We estimated that using 2 x API Keys we would roughly be able to obtain a week's worth of data. However, upon implementation we realized that there was a row for every code-share, meaning some flights that were operated by an alliance of airlines had 7 different flight codes so 7 rows describing the same physical flight.

Finally, we decided on also filtering our request to include just American Airlines this way we avoid the code-share issue and could still get enough data to analyze over time.

### Implementation

Below is our R code, which includes the initial GET request and then a loop that facilitates pagination with a next cursor.


These are the features that differ from our first attempt at getting arrivals data but we soon realized the magnitude of the data and decided to pivot our request to only request American Airlines, rather than all airlines.

We chose American Airlines because it is the airline we fly frequently ourselves and has both domestic and international flights.

```{r Original Code Features, eval = FALSE}
#Our first API key
url <- "https://flight-info-api.p.rapidapi.com/status"
api_key = '2a26d82d2fmsh3b29970cdca97d1p138b78jsn60a78272a81e'
api_host = 'flight-info-api.p.rapidapi.com'

#Our original query string without the filter
queryString <- list(
  version = "v2",
  ArrivalDateTime = "2024-08-01T00:00/2024-09-01T00:00",
  ArrivalAirport = "ORD",
  FlightType = "Scheduled",
  CodeType = "IATA",
  ServiceType = "Passenger")
  
  #The original line we used to write our JSOn
  write_json(content, 'flightAPIJson.json')

  #The original line we used to write our flight data to CSV
  write.csv(flight_data, 'requestA.csv', row.names=FALSE)


```


This is the final code that we used for our American Airlines only requests. The query string changes to include the CarrierCode = 'AA' and the csv and json file names change so we write to another place. 

```{r Historical Flight Arrivals American Airlines, eval = FALSE}

library(httr)
library(jsonlite)
library(tidyr)

#Query String for only American Airlines to ORD
#We started from 15:52 as we already had data up to 15:51 from our initial attempt with all airlines
queryString <- list(
  version = "v2",
  ArrivalDateTime = "2024-08-01T15:52/2024-09-01T00:00",
  ArrivalAirport = "ORD",
  FlightType = "Scheduled",
  CodeType = "IATA",
  ServiceType = "Passenger",
  CarrierCode = "AA"



#Initial API Request
url <- 'https://flight-info-api.p.rapidapi.com/status'

#GET request
#We used a second API key as we reached our limit on the first one
response <- VERB('GET', url = url, query = queryString, add_headers('x-rapidapi-key' = '572d8c59b1mshca4d962b7338c05p17bb46jsnfa4dbd8e8c4d', 'x-rapidapi-host' = 'flight-info-api.p.rapidapi.com'), content_type("application/octet-stream"))

content <- content(response, "text")

json <- fromJSON(content)

list_data <- jsonlite::flatten(json$data) #flatten data frame, still with some nesting, will need to be cleaned

write_json(content, 'flightAPIJson3.json')

paging_next <- parse_response(list_data)



#Subsequent API requests where we use the cursor to navigate to the next page
while (paging_next != ""){

  response <- VERB('GET', url = paging_next, add_headers('x-rapidapi-key' = '572d8c59b1mshca4d962b7338c05p17bb46jsnfa4dbd8e8c4d', 'x-rapidapi-host' = 'flight-info-api.p.rapidapi.com'), content_type("application/octet-stream"))
  
  #This we break the loop if a request fails, including 429 when we reach limit
  if (status_code(response) != 200) {
    print("Error with request")
    break #break out of while
    
  }
  
  content <- content(response, "text")
  json <- fromJSON(content)
  list_data <- jsonlite::flatten(json$data) #flatten data frame, still with some nesting, will need to be cleaned

  
  #Writing JSON resp to file incase something happens
  existing_data <- fromJSON("flightAPIJson3.json")
  
  combined_data <- append(existing_data, content)
  
  write_json(combined_data, 'flightAPIJson3.json')
  
  #Parse data and write to CSV
  paging_next <- parse_response(list_data)
  
  Sys.sleep(7) #Add a pause to make sure we stay below the 10 requests per min limit  

  
}


##Function that parses data from the request into a df and then writes to a csv
parse_response(list_data){
  
  flight_data = data.frame()
  for (i in 1:nrow(list_data)) {
    
    data = list_data[i,]
    new_row1 <- data.frame(
      airline = data$carrier.iata,
      timeOfFlight = data$elapsedTime,
      deptAirport = data$departure.airport.iata,
      arrAirport = data$arrival.airport.iata,
      arrDay = data$arrival.date.local,
      arrTime = data$arrival.time.local,
      deptCountry = data$departure.country.code,
      flightNumber = data$flightNumber,
      
      estimatedOutGateVariation = ifelse(is.null(list_data$statusDetails[[i]]$departure$estimatedTime$outGateVariation[[1]]), NA, list_data$statusDetails[[i]]$departure$estimatedTime$outGateVariation[[1]]),
      estimatedOutGate = ifelse(is.null(list_data$statusDetails[[i]]$departure$estimatedTime$outGate), NA, list_data$statusDetails[[i]]$departure$estimatedTime$outGate[[1]]),
      estimatedOffGround = ifelse(is.null(list_data$statusDetails[[i]]$departure$estimatedTime$offGround), NA, list_data$statusDetails[[i]]$departure$estimatedTime$offGround[[1]]),
      actualOutGateVariation = ifelse(is.null(list_data$statusDetails[[i]]$departure$actualTime$outGateVariation), NA, list_data$statusDetails[[i]]$departure$actualTime$outGateVariation[[1]]),
      actualOutGate = ifelse(is.null(list_data$statusDetails[[i]]$departure$actualTime$outGate), NA, list_data$statusDetails[[i]]$departure$actualTime$outGate[[1]]), 
      actualOffGround = ifelse(is.null(list_data$statusDetails[[i]]$departure$actualTime$offGround), NA, list_data$statusDetails[[i]]$departure$actualTime$offGround[[1]]),
      
      estimatedInGateVariation = ifelse(is.null(list_data$statusDetails[[i]]$arrival$estimatedTime$inGateVariation), NA ,list_data$statusDetails[[i]]$arrival$estimatedTime$inGateVariation[[1]]),
      estimatedInGate = ifelse(is.null(list_data$statusDetails[[i]]$arrival$estimatedTime$inGate), NA, list_data$statusDetails[[i]]$arrival$estimatedTime$inGate[[1]]),
      estimatedOnGround = ifelse(is.null(list_data$statusDetails[[i]]$arrival$estimatedTime$onGround), NA, list_data$statusDetails[[i]]$arrival$estimatedTime$onGround[[1]]),
      actualInGateVariation = ifelse(is.null(list_data$statusDetails[[i]]$arrival$actualTime$inGateVariation), NA, list_data$statusDetails[[i]]$arrival$actualTime$inGateVariation[[1]]), 
      actualInGate = ifelse(is.null(list_data$statusDetails[[i]]$arrival$actualTime$inGate), NA, list_data$statusDetails[[i]]$arrival$actualTime$inGate[[1]]),
      actualOnGround = ifelse(is.null(list_data$statusDetails[[i]]$arrival$actualTime$onGround), NA, list_data$statusDetails[[i]]$arrival$actualTime$onGround[[1]]),
      
      arrTerminal = ifelse(is.null(list_data$statusDetails[[i]]$arrival$actualTerminal), NA, list_data$statusDetails[[i]]$arrival$actualTerminal),
      arrGate = ifelse(is.null(list_data$statusDetails[[i]]$arrival$gate), NA, list_data$statusDetails[[i]]$arrival$gate),
      
      numStops  = data$segmentInfo.numberOfStops,
      connections = I(list(connections(list_data$segmentInfo.numberOfStops[[i]], list_data$segmentInfo.intermediateAirports.iata[[i]]))),
      miles = data$distance.accumulatedGreatCircleMiles
    )
    
    
    
    flight_data <- rbind(flight_data, new_row1)
  }
  # Identify list columns
  list_columns <- sapply(flight_data, is.list)
  
  # Convert list columns to character vectors
  flight_data[list_columns] <- lapply(flight_data[list_columns], function(x) sapply(x, toString))
  # Append new data to the same CSV file
  write.table(flight_data, "AmericanAirlines2.csv",
              append = TRUE,
              sep = ",",
              col.names = FALSE,
              row.names = FALSE,
              quote = FALSE)
  paging_next <- json$paging$`next`
  return(paging_next)
}


#Function that turns connections into a list to insert into df
connections <- function(stops, stops_list) {
  conn_list <- list()
  if (stops == 0) {
    conn_list <- append(conn_list, "None")
  }
  else {
    for (i in 1:stops) {
      conn_list <- append(conn_list, list(stops_list$station[i]))
    }
  }
  return (conn_list)
}

```


## Airport Wait Times
We obtained this data using FORM request on the https://awt.cbp.gov/ website. At first, we searched the page html to find the appropriate ID for Chicago O'Hare Aiport then we specified the date range for wait time collection. This will be performed after the flight API request as this will guide how many days we need to get wait times for.

###Implementation
Below is our R code, which submits a HTML form and returns a HTML table to clean into a data frame.

```{r Airport Wait Times, eval = FALSE}
library(httr) # httr is organised around the six most common http verbs: GET(), PATCH(), POST(), HEAD(), PUT(), and DELETE().
library(rvest) # Easily Harvest (Scrape) Web Pages
library(tidyverse)
library(stringr)
library(jsonlite)


#Found in the HTML of the website
ord_id <- 'ORD'
t5_id <- 'A392'
#form request
awt_session <- session("https://awt.cbp.gov/")
form <- html_form(awt_session)[[1]]
form_filled <- html_form_set(form, Id = 'ORD', FromDate = '08/01/2024', ToDate = '09/01/2024')
answer <- session_submit(awt_session, form_filled)
answer
tbl <- data.frame(html_table(answer)[[1]])
for (i in (5:20)){
  colnames(tbl)[i] <- paste0(paste0(tbl[1, i], " "), gsub("\\s+", "_", tbl[2, i]))
}

colnames(tbl)[c(5,7)] <- c('US_Average_Wait_Time', 'Non_US_Average_Wait_Times')
tbl <- tbl %>% select(-All.12) %>% slice(-c(1, 2))
write.csv(tbl, 'waitTimes1.csv', row.names=FALSE)




```

```{r Data Frame Preview1}
wait_data <- read.csv('waitTimes1.csv')
head(wait_data)
```


## Data Description
Describe the structure of the dataset that was acquired and any cleaning or preprocessing that was performed on the data to prepare it for analysis. Describe interesting data points that merit attention and some summary statistics to give a general overview of your data.

#### The Form API data from: https://awt.cbp.gov/.
With this API, we get a list of wait times for the desired airport within the date range we provide. This dataset includes average and max wait times for US, Non-US citizens, and all people. 

#### The REST API data from: https://rapidapi.com/oag-oag-default/api/flight-info-api
Each request (and associated json) had 100 rows. Each row contained 17 elements: carrier, serviceSuffix, flightNumber, flightType, departure, arrival, elapsedTime, cargoTonnage, aircraftType, serviceType, segmentInfo, distance, codeshare, scheduleInstanceKey, statusKey, and statusDetails. Within departure, arrival, distance, and statusDetails were further information about the flight. Cleaning the data required finding the elements that we wanted to use in our analysis and making them into a data frame. Most data points could be put directly into the data frame without manipulation. However, the connecting flights column was created with a function that extracted the connecting flights, if they existed. Also some fields did not exist in the request so we needed validation to enter NA in order for the data frame to still be created.

##Exploratory Analysis
```{r}
library(dplyr)
library(lubridate)
library(stringr)
library(hms)
library(caret)
library(tidyr)
library(car)
library(ggplot2)
library(countrycode)
library(gridExtra)
library(lubridate)
```


#### Summary Statistics for Flights
```{r Summary Statistics1}
summary(aa)
aa$CountryName <- countrycode(aa$deptCountry, origin = "iso2c", destination = "country.name")


# Plot of most common hours
arrivals$arrHour <- as.numeric(format(strptime(aa$arrTime, format = "%H:%M"), "%H"))
arrivals$international <- ifelse(aa$deptAirport !=  'US', 1,0)
arrivals <- arrivals %>%
  group_by(arrHour) %>%
  summarize(Count = n())


ggplot(aa, aes(x=arrHour)) + geom_bar(fill = '#F8766D') +
  labs(title = 'Number of Arrivals per Hour',subtitle = '8/1/24 - 8/7/24', x = 'Hour', y = 'Count') + theme_minimal()

ggplot(aa[aa$international==1,], aes(x=arrHour)) + geom_bar(fill = '#F8766D') +
  labs(title = 'Number of International Arrivals per Hour',subtitle = '8/1/24 - 8/7/24', x = 'Hour', y = 'Count') + theme_minimal()
```

The most common hours for both domestic and flights to arrive are around the middle of the day. However, domestic flights peak earlier than international flights starting to pick up at around 7am. This makes sense as to account for time difference, very few international flights (from American Airlines which are generally coming from Europe) land early in the morning in the US.

```{r}

international_delay <- aa[aa$deptCountry != 'US',] %>% mutate(delayed = ifelse(grepl('^-', actualInGateVariation), 1, 0)) %>% select(CountryName, delayed) %>% group_by(CountryName) %>% summarise(del = sum(delayed)/n(), over = ifelse(del >= 0.5, 1, 0))
international_delay$color <- ifelse(international_delay$over, '#00BA38',"#F8766D")

dow_delay <- aa 
dow_delay$weekday <- wday(aa$arrDay, label = TRUE)
dow_delay <- dow_delay%>% mutate(delayed = ifelse(grepl('^-', actualInGateVariation), 1, 0)) %>% select(weekday, delayed) %>% group_by(weekday) %>% summarise(del = sum(delayed)/n())

# Plot of delays in international airports
ggplot(international_delay, aes(x = CountryName, y = del, fill =color)) +
  geom_bar(stat = "identity") +
  guides(x = guide_axis(angle = 45)) +
  labs(title = 'Delayed International Arrivals', subtitle = '8/1/24 - 8/7/24', x = 'Country', y = '% of Flights Delayed') +
  scale_y_continuous(labels = scales::percent) +
    guides(fill = "none") +  # Remove the legend
  theme_minimal()

```

When looking at delays by country, there is no significant outliers for countries that are consistently delayed. However, we can see that in this period there were no delayed flights from PR or Finland. This may be useful going forward to use country as a feature to predict delay. However, it would be more useful if we could compare different airlines per country as then people could make an informed choice on which airline to choose based on delays.

```{r}
# Plot of delays by dow

dow_delay$color <- ifelse(dow_delay$weekday == 'Mon', "green", ifelse(dow_delay$weekday == 'Wed', "blue", "red"))
ggplot(dow_delay, aes(x = weekday, y = del, fill = color)) +
  geom_bar(stat = "identity") +
  guides(x = guide_axis(angle = 45)) +
  labs(title = 'Delayed Flights by DOW', subtitle = '8/1/24 - 8/7/24', x = 'DOW', y = '% of Flights Delayed') +
  scale_y_continuous(labels = scales::percent) +
  guides(fill = "none") +  # Remove the legend
  theme_minimal()

```

For all flights, we can see that Wednesday experiences the most delays and Monday seems to have significantly more on-time flights than the others days. This could be because it is the start of the week and there are no delays from previous days that have a knock-on effect at this point.

#### Summary Statistics for Wait Times
```{r Summary Statistics}
summary(wait)

per_date <- wait %>% group_by(Date) %>% summarise(Avg_US =  mean(US_Average_Wait_Time), Avg_NonUS = mean(Non_US_Average_Wait_Times)) %>% pivot_longer(cols = c(Avg_US, Avg_NonUS), names_to = 'Status')
per_date$weekday <- wday(per_date$Date, label = TRUE)

per_date_max <- wait %>% group_by(Date) %>% summarise(Max_US =  max(US_Max_Wait_Time), Max_NonUS = max(Non_US_Max_Wait_Time)) %>% pivot_longer(cols = c(Max_US, Max_NonUS), names_to = 'Status')
per_date_max$weekday <- wday(per_date$Date, label = TRUE)


per_hour_wait <- wait[,c(5, 7, 23)]
per_hour_wait <- per_hour_wait %>% group_by(arrStart) %>% summarise(Avg_US =  mean(US_Average_Wait_Time), Avg_NonUS = mean(Non_US_Average_Wait_Times)) %>% pivot_longer(cols = c(Avg_US, Avg_NonUS), names_to = 'Status')

stacked_hourly <- ggplot(per_hour_wait, aes(x = arrStart, y = value, fill = Status)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(title = "Stacked Bar Plot for Avg Wait Times of US and Non-US Citizens By Hour",
       subtitle = '8/1/24 - 8/7/24',
       x = "Hour",
       y = "Avg Wait in Mins",) 
  theme_minimal()
stacked_hourly
```
If we look at the average wait time per hour, there is not much difference between US and Non-US Citizens. However, you can see between 3-4am and 5-11pm it is significantly faster compared to the later hours between 11pm and 2am and the middle of the day between 5am and 4pm. This doesn't really make sense as our flight data indicated that all international flights are landing after 5pm so that would be when international arrivals is busiest.

There are two explanations for why this data is not as expected.
1. We only used American Airlines, which flies to a lot of international destination but not all. Specifically, not many countries in the Pacific. Most international flights from Europe will land in the late afternoon/evening in the US because of time difference. So there could be a large number of flights that are landing in the middle of the day from other airlines that are increasing wait times but are not showing up in our analysis.

2. Number of flights might not be exactly proportional to wait times as certain international citizens take longer to get through customs than others. For example, a large number of flights from Ireland may not take too long to get through border control as they have pre-clearance in Ireland. However, a singular flight from Australia or China might take a lot longer to get through customs as the US has different/more strict immigration policies.

```{r}
# Create the stacked bar plot
stacked_avg <- ggplot(per_date, aes(x = weekday, y = value, fill = Status)) +
  geom_bar(stat = "identity") +
  labs(title = "Stacked Bar Plot for Avg Wait Times of US and Non-US Citizens by DOW",
       subtitle = '8/1/24 - 8/7/24',
       x = "DOW",
       y = "Average Wait in Mins",) 
  theme_minimal()

stacked_max <- ggplot(per_date_max, aes(x = weekday, y = value, fill = Status)) +
  geom_bar(stat = "identity") +
  labs(title = "Stacked Bar Plot for Max Wait Times of US and Non-US Citizens by DOW",
       subtitle = '8/1/24 - 8/7/24',
       x = "DOW",
       y = "Max Wait in Mins",) 
  theme_minimal()


grid.arrange(stacked_max, stacked_avg, nrow =2)
```

You can see there is not much difference in Max Wait Times but for Average Wait Times, they are slightly longer for Non-US citizens, which is expected. In addition, Wednesday and Monday seem to be the busiest and Sunday is the quietest for arriving in O'Hare.


##Discussion
If you are most concerned about flight delay, the best day to fly would be Monday as that had a significantly smaller % of delayed flights and the worst days would be Sunday or Wednesday. This is most useful for domestic flyers as that is the majority of our data and they do not have to take into account wait times in customs.

However, if you are flying internationally, you want to make sure your flight lands after 4pm to ensure the shortest wait times in customs. Furthermore, for flights from Puerto Rico and Finland, American Airlines seems like a reliable/on time service to choose but for some other countries, you may want to consider another airline.


## Data Manipulation
#### Merging the Dataframes
From our two APIs, we had a dataframe of wait times (by hour) and a week of American Airlines flights into Chicago O'Hare. To merge the two dataframes, we had to find the row within the wait times dataframe where the arrival time (of the AA flight) fit into the hour-long windows of the wait times dataframe.

We began by cleaning both the AA and wait dataframes.
  - Converting the date column to a date
  - Splitting the hour-long windows into start and end hours (ex: 0000-0100 into 00:00, 01:00)
  - Converting all times into total minutes for easy comparison.
  
Here is the code for the merge. 
```{r Merge DFs}
result <- data.frame()
for (i in 1:nrow(aa)) {
  df1 <- aa[i,]
  matched_row <- wait %>%
    filter(Date == df1$arrDay, 
           arrStartMins <= df1$arrMinutes,
           arrEndMins >= df1$arrMinutes)
  combined_row <- df1
  if (nrow(matched_row) > 0) {
    for (j in 5:ncol(matched_row)) {
      col_name <- colnames(matched_row)[j]  
      combined_row[[col_name]] <- matched_row[1, j]
    }
  result <- rbind(result, combined_row)
  }
}
```

Within this dataframe merge, NAs presented some challenges. Whenever an NA was present in the current row of the AA flights dataframe, all the new values to be merged resulted in NA when using column bind (cbind). Our solution was to introduce another if statement that binded these two pieces to 'combined_row' separately.

We then saved this final dataframe as a csv file. 
```{r Results CSV}
result <- read.csv('AA_wait_merged.csv')
head(result)
summary(result)
```

This 'result' dataframe will be used for all analysis and modeling in the next sections.

## Regression Analysis & Results 
#### Logistic Model
Because delay is a binary classifier (1 - delay, 0 - no delay), we used a logistic regression model to predict whether a flight would be delayed. A logistic model is able to handle categorical predictors, and because it is a fairly simple model in design, is much more efficient than some other models. One limitations of using this model is that it assumes a linear relationship between our predictors and the log-odds of our outcome variable (delayed). 
Below is the code for this model. The predictors are: departure airport, departure time estimated variation, and day of week.
```{r Logistic Delay Model}
no_na <- na.omit(result)
delay_mod <- glm(delayed ~ deptAirport + DayOfWeek + outGateVarEst, 
             data = no_na, 
             family = binomial)

predicted_prob <- predict(delay_mod, type = "response")
predicted_class <- ifelse(predicted_prob > 0.5, 1, 0)
table(Actual = no_na$delayed, Predicted = predicted_class)
confusionMatrix(as.factor(predicted_class), as.factor(no_na$delayed))
```

There are three key takeaways from this model. Overall, we see a balanced accuracy of 85%, meaning that the predictors we chose are good predictors of having a delay.
The sensitivity and specificity values also reveal important model characteristics. The 'positive' class in our model is 0 (no delay), so that is the class to which our sensitivity score explains. Our model's sensitivity is  0.9672, meaning that the model correctly identified 97% of cases where there was no delay. The other 3% of no-delay cases were incorrectly labeled as delay. Our model's specificity is  0.7308, meaning that the model correctly identified 73% of cases where there was a delay. The other 27% of delay cases were misclassified as no delay. 

Because our sensitivity and specificity values were high, our model was fairly good at predicting both classes of delay. It was not very much skewed toward one factor or another; i.e. this model could be useful in predicting whether a flight will be delayed.

#### Linear Models
We then ran some linear models to predict the wait time once at Chicago O'Hare airport (after landing). A linear model can use both factor (categorical) and numerical predictors, and it creates a simple, understandable model for the outcome variable. Using a linear model means that we assume a linear relationship between our predictors and outcome variable (wait time in minutes). When analyzing these models, there are several important metrics. The r-squared value shows the strength of our model to predict our outcome variables. This value ranges from 0 - 1, with a value of 1 representing a model that predicts perfectly. Looking at our predictors, the intercept represents the increase/decrease in our outcome variable (wait time) for a change of one unit in the specific predictor. The significance codes of these predictors reveal how well they serve as predictors. Our goal is the lowest level of significance code (0.001), meaning that the variable is a strong predictor in our model.

The predictors for all models were: day of week and arrival time. The outcome variables for the 3 models were: average wait time, US citizen average wait time, and Non-US citizen average wait time.

```{r Wait Model 1}
wait_mod <- lm(Wait.Times.Average_Wait_Time ~ DayOfWeek + arrMinutes,
               data = result)
summary(wait_mod)
crPlots(wait_mod)
```

In our first wait model, we predict overall average wait time (for both US and Non-US citizens). Our model has an adjusted r-squared value of 0.4453, meaning that this model is not the greatest in terms of predicting overall wait time. Our model has two significant predictors: day of week and arrival time. 
Arrival time (in minutes) is significant at the 0.001 level. It has a slight negative relationship with wait time: adding one minute to arrival time (later in the day) decreases the average wait time by 0.033 minutes.
Because day of week is a categorical variable, we can analyze the significance of the different levels. Sunday, Monday, and Wednesday are significant at the highest level (0.001). All have a positive relationship with wait time. If the flight occurs on a Sunday, the wait time increases by -11 minutes. If the flight occurs on a Monday, the wait time increases by 5 minutes. Finally, if the flight occurs on a Wednesday, the wait time increases by 25 minutes.
  
The next two models subset our original dataset. The first looks at only flights departing from within the US and predicts average wait time for a US citizen. The second model subsets to only non-US departing airports, and predicts average wait time for a Non-US citizen.

```{r Wait Model 2}
us_data <- result %>%
  filter(deptCountry == 'US')
us_mod <- lm(US_Average_Wait_Time ~ DayOfWeek + arrMinutes,
             data = us_data)
summary(us_mod)
crPlots(us_mod)
```

For this US citizen model, we see an adjusted r-squared of 0.4692, meaning that our model is not the greatest predictor for US wait time. Once again, arrival time is significant at the 0.001 level, and it has a slight negative relationship with US citizen wait time. An increase in one minute in the arrival time decreases the wait time by 0.03 minutes. In terms of day of the week - Sunday, Tuesday, Wednesday, and Thursday are significant at the 0.001 level. Sunday, Tuesday, and Thursday have a negative relationship with wait time. On Sunday, the wait time decreases by 11 minutes; on Tuesday, the wait time decreases by 4 minutes; on Thursday, the wait time decreases by 6 minutes. Wednesday has a positive relationship with wait time, as it increases wait time by 20 minutes. 

```{r Wait Model 3}
non_us_data <- result %>%
  filter(deptCountry != 'US')
non_us_mod <- lm(Non_US_Average_Wait_Times ~ DayOfWeek + arrMinutes,
             data = non_us_data)
summary(non_us_mod)
crPlots(non_us_mod)
```

In this model, our outcome variable is the average wait time for Non-US citizens. We see an adjusted r-squared of 0.504, meaning that our model is not the best at prediction. However, we see some significant variables. Like in our previous models, arrival time is significant at the 0.001 level, and it once again has a slight negative relationship with wait time. In terms of days of the week, only Monday and Wednesday are significant at the 0.001 level. Both had a positive relationship with wait time. Monday increases the wait time by 27 minutes, and Wednesday increases the wait time by 43 minutes.
In all our linear models, in-gate variation was not a significant variable. Next steps would include running models with other variables instead of in-gate variation.

All of our models provide actionable insights for travelers, which we will explain in the following section.

## Discussion 
With our data analysis, we hoped to be able to predict delays and airport wait times for American Airlines flights into Chicago O'Hare. 

In our binary model, we predicted whether a flight will be delayed using departure airport, departure gate estimated variation, and the day of the week. Our model had a 85% accuracy, meaning that this model would be useful to predict a flight's delay status.

```{r Prediction on Flight}
test_data <- data.frame(deptAirport = c('LHR'), DayOfWeek = c('Wed'), outGateVarEst = c(-9))
predicted_prob_test <- predict(delay_mod, type = "response", newdata = test_data)
predicted_class_test <- ifelse(predicted_prob_test > 0.5, 1, 0)
predicted_class_test[1]
```


We then ran three linear models, all of which provided similar insights about wait time. In all three models, we found that a later arrival time led to a slight decrease in wait time, for both US and Non-US citizens. As a result, we would recommend that people fly later in the day to decrease their wait time at the airport. 
All our linear models also reveal information about wait time related to the day of the flight. For all people, Wednesday is the worst day to fly, as it increases the wait time by about 30 minutes. Flying on a Monday also leads to a longer wait time, although not as lengthy as a Wednesday. There were several days that shorten wait time: Sunday, Tuesday, and Thursday (for US travelers). We would recommend people fly on Sunday, Tuesday, and Thursday, and do not fly on Monday or Wednesday.
Below is a summary of these outcomes for day of the week:
1. All travelers:
  - Sunday: -11 minutes
  - Monday: +5 minutes
  - Wednesday: +25 minutes
  
2. US travelers:
  - Wednesday: +20 minutes
  - Sunday: -11 minutes
  - Tuesday: -4 minutes
  - Thursday: -6 minutes
  
3. Non-US travelers:
  - Monday: +27 minutes
  - Wednesday: +43 minutes

Our main data limitations is the time period of the data. With our free API, we could only do a limited number of requests; using two accounts only allowed for a week's worth of data. To further validate our analyses, we would want to gather many more weeks of data and run our models again. Additionally, we would want to gather data on more than one airline and analysis waits/delays for these different airlines.

## References
API Websites/Documentation:
  - A Form API of wait times for customs from international flights arriving into Chicago O'Hare, one of the major US airports.
       - https://awt.cbp.gov/
   - A REST API of historical flight arrivals data
        - https://rapidapi.com/oag-oag-default/api/flight-info-api
  
Test Flight: 
  - https://www.aa.com/travelInformation/flights/status/detail?search=AA|87|LHR|ORD|2024,10,2&ref=results
